/* Code generated by AI (Claude 3.5 Sonnet) */

import type { Article } from '../types/Article';
import type { ArticleSourceConfig } from '../types/ArticleSource';
import { parseDate } from '../utils/dateUtils';

export class ArticleFetcher {
  private readonly config: ArticleSourceConfig;
  private parsedTransformers: Record<string, ((value: string) => string) | undefined>;

  constructor(config: ArticleSourceConfig) {
    this.config = config;
    this.parsedTransformers = this.parseTransformers(config.transformers || {});
  }

  private parseTransformers(transformers: Record<string, string | undefined>): Record<string, ((value: string) => string) | undefined> {
    const parsed: Record<string, ((value: string) => string) | undefined> = {};
    
    for (const [key, transformer] of Object.entries(transformers)) {
      if (transformer) {
        try {
          // Create a function from the transformer string
          parsed[key] = new Function('url', `return ${transformer}`) as (value: string) => string;
        } catch (error) {
          console.error(`Error parsing transformer for ${key}:`, error);
          parsed[key] = undefined;
        }
      }
    }
    
    return parsed;
  }

  async fetchArticles(): Promise<Article[]> {
    try {
      const url = this.config.corsProxy 
        ? `${this.config.corsProxy}${encodeURIComponent(this.config.baseUrl)}`
        : this.config.baseUrl;

      const response = await fetch(url);
      
      if (!response.ok) {
        const errorMessage = this.getErrorMessage(response.status);
        throw new Error(errorMessage);
      }
      
      const html = await response.text();
      const doc = new DOMParser().parseFromString(html, 'text/html');
      
      const container = doc.querySelector(this.config.selectors.container);
      if (!container) throw new Error('Article container not found');

      const articleElements = Array.from(container.children);
      
      return articleElements
        .map(element => this.parseArticle(element))
        .filter(article => article.title && article.articleUrl);
    } catch (error) {
      console.error(`Error fetching articles from ${this.config.name}:`, error);
      throw error;
    }
  }

  private getErrorMessage(status: number): string {
    switch (status) {
      case 403:
        return `Access Forbidden (403) - The server blocked access to ${this.config.name}. This might be due to CORS restrictions or rate limiting.`;
      case 404:
        return `Not Found (404) - The source ${this.config.name} is not available at this URL.`;
      case 429:
        return `Too Many Requests (429) - Rate limit exceeded for ${this.config.name}. Please try again later.`;
      case 500:
        return `Server Error (500) - ${this.config.name}'s server encountered an error.`;
      case 502:
        return `Bad Gateway (502) - Unable to reach ${this.config.name}'s server.`;
      case 503:
        return `Service Unavailable (503) - ${this.config.name} is temporarily unavailable.`;
      case 504:
        return `Gateway Timeout (504) - Request to ${this.config.name} timed out.`;
      default:
        return `HTTP error ${status} when fetching articles from ${this.config.name}`;
    }
  }

  private parseArticle(element: Element): Article {
    const { selectors } = this.config;
    
    const title = element.querySelector(selectors.title)?.textContent?.trim() || '';
    const rawUrl = element.querySelector(selectors.link)?.getAttribute('href') || '';
    const articleUrl = this.parsedTransformers.articleUrl ? this.parsedTransformers.articleUrl(rawUrl) : rawUrl;
    
    const rawImage = element.querySelector(selectors.image);
    const imageUrl = rawImage?.getAttribute('src') || rawImage?.getAttribute('data-src') || '';
    
    const dateEl = element.querySelector(selectors.date);
    const rawDate = dateEl?.getAttribute('datetime') || dateEl?.textContent || '';
    
    // Format date using the dateFormat from config if available
    const formattedDate = parseDate(rawDate, this.config.dateFormat, this.config.name);

    return {
      id: articleUrl,
      title,
      description: element.querySelector(selectors.description)?.textContent?.trim() || '',
      imageUrl: this.parsedTransformers.imageUrl ? this.parsedTransformers.imageUrl(imageUrl) : imageUrl,
      date: formattedDate,
      articleUrl,
      sourceName: this.config.name,
      category: this.config.category
    };
  }
}
